import { loadConfig } from '../utils/config.js';
import { NETWORKS } from '../types/index.js';
import type { LogEntry, Checkpoint } from '../types/index.js';

export class ReportGenerator {
  generate(
    logs: LogEntry[],
    checkpoints: Checkpoint[],
    options?: { projectName?: string; reflection?: string }
  ): string {
    const config = loadConfig();
    const network = NETWORKS[config.network.name];
    const explorerUrl = network?.explorerUrl || 'https://bscscan.com';
    const projectName = options?.projectName || this.detectProjectName();

    const totalLines = logs.reduce(
      (acc, l) => ({
        added: acc.added + (l.diff?.linesAdded || 0),
        deleted: acc.deleted + (l.diff?.linesDeleted || 0),
      }),
      { added: 0, deleted: 0 }
    );

    const aiTools = new Set<string>();
    logs.forEach((l) => {
      if (l.aiContext?.tool) aiTools.add(l.aiContext.tool);
    });

    const startDate = logs.length > 0
      ? new Date(logs[0].timestamp * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
      : 'N/A';
    const endDate = logs.length > 0
      ? new Date(logs[logs.length - 1].timestamp * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
      : 'N/A';

    let md = `# ðŸ”¨ Build Log: ${projectName}\n\n`;
    md += `**Built for**: Good Vibes Only: OpenClaw Edition\n`;
    md += `**Builder**: \`${config.wallet.address}\`\n`;
    md += `**Chain**: ${network?.name || config.network.name}\n`;
    md += `**Build Period**: ${startDate} - ${endDate}\n\n`;
    md += `---\n\n`;

    // Statistics
    md += `## ðŸ“Š Build Statistics\n\n`;
    md += `- **Total Build Sessions**: ${logs.length}\n`;
    md += `- **Onchain Checkpoints**: ${checkpoints.length}\n`;
    md += `- **Lines Added**: +${totalLines.added}\n`;
    md += `- **Lines Deleted**: -${totalLines.deleted}\n`;
    if (aiTools.size > 0) {
      md += `- **AI Tools Used**: ${Array.from(aiTools).join(', ')}\n`;
    }
    md += `\n---\n\n`;

    // Build Narrative
    md += `## ðŸŒŸ Build Narrative\n\n`;

    const sessionsByDay = this.groupByDay(logs);
    for (const [day, dayLogs] of Object.entries(sessionsByDay)) {
      md += `### ${day}\n\n`;

      for (const log of dayLogs) {
        const time = new Date(log.timestamp * 1000).toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit',
          timeZone: 'UTC',
        });

        md += `**${time} UTC** - ${log.message}\n\n`;

        if (log.commit) {
          md += `- Commit: \`${log.commit.hash}\` - ${log.commit.message}\n`;
        }
        if (log.diff) {
          md += `- Changes: ${log.diff.filesChanged} files (+${log.diff.linesAdded}/-${log.diff.linesDeleted})\n`;
          if (log.diff.files.length > 0) {
            md += `- Files: ${log.diff.files.slice(0, 5).join(', ')}${log.diff.files.length > 5 ? ` (+${log.diff.files.length - 5} more)` : ''}\n`;
          }
        }
        if (log.aiSummary) {
          md += `\n> ${log.aiSummary}\n`;
        }
        md += `\n`;
      }
      md += `---\n\n`;
    }

    // Onchain Checkpoints
    if (checkpoints.length > 0) {
      md += `## ðŸ”– Onchain Checkpoints\n\n`;
      md += `All build activity is verifiable onchain:\n\n`;

      for (let i = 0; i < checkpoints.length; i++) {
        const cp = checkpoints[i];
        const date = new Date(cp.timestamp * 1000).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric',
        });
        md += `${i + 1}. **${date}** - ${cp.summary} ([Proof](${explorerUrl}/tx/${cp.blockchain.txHash}))\n`;
        md += `   - Hash: \`${cp.logHash.substring(0, 16)}...\`\n`;
        md += `   - Logs included: ${cp.logs.length}\n`;
      }
      md += `\n---\n\n`;
    }

    // Reflection
    if (options?.reflection) {
      md += `## ðŸ’­ Reflection\n\n`;
      md += `${options.reflection}\n\n`;
      md += `---\n\n`;
    }

    // Footer
    md += `*This build log was automatically generated by [VibeLog](https://github.com/PugarHuda/VibeLog)*\n`;
    const zeroAddr = '0x0000000000000000000000000000000000000000';
    if (config.network.contractAddress && config.network.contractAddress !== zeroAddr) {
      md += `*Verified Onchain: [${config.network.contractAddress}](${explorerUrl}/address/${config.network.contractAddress})*\n`;
    }
    md += `*Verify online: [VibeLog Verifier](https://nicholasrossi0530.github.io/VibeLog/)*\n`;

    return md;
  }

  private groupByDay(logs: LogEntry[]): Record<string, LogEntry[]> {
    const groups: Record<string, LogEntry[]> = {};
    for (const log of logs) {
      const day = new Date(log.timestamp * 1000).toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });
      if (!groups[day]) groups[day] = [];
      groups[day].push(log);
    }
    return groups;
  }

  private detectProjectName(): string {
    try {
      const parts = process.cwd().split(/[/\\]/);
      return parts[parts.length - 1] || 'My Project';
    } catch {
      return 'My Project';
    }
  }
}
